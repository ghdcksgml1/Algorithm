# 알고리즘 정리 🙂

<br/>

혹시나 틀린부분이 있다면 언제든 지적해주세요!!

<br/>

<table>
  <tr>
    <td align="center"><strong>순서</strong></td>
    <td align="center"><strong>알고리즘</strong></td>
    <td align="center"></td>
    <td align="center">시간 복잡도</td>
  </tr>
  <tr>
    <td align="center">01</td>
    <td align="center">선택 정렬</td>
    <td align="center">Select Sort</td>
    <td align="center">O(N<sup>2</sup>)</td>
  </tr>
  <tr>
    <td align="center">02</td>
    <td align="center">버블 정렬</td>
    <td align="center">Bubble Sort</td>
    <td align="center">O(N<sup>2</sup>)</td>
  </tr>
  <tr>
    <td align="center">03</td>
    <td align="center">삽입 정렬</td>
    <td align="center">Insertion sort</td>
    <td align="center">O(N<sup>2</sup>)</td>
  </tr>
  <tr>
    <td align="center">04</td>
    <td align="center">퀵 정렬</td>
    <td align="center">Quick Sort</td>
    <td align="center">평균: O(NlogN), 최대: O(N<sup>2</sup>)</td>
  </tr>
  <tr>
    <td align="center">05</td>
    <td align="center">병합 정렬</td>
    <td align="center">Merge Sort</td>
    <td align="center">O(N<sup>2</sup>)</td>
  </tr>
  <tr>
    <td align="center">06</td>
    <td align="center">STL::Sort 사용</td>
    <td align="center">sortMethod</td>
    <td align="center">O(N<sup>2</sup>)</td>
  </tr>
  <tr>
    <td align="center">07</td>
    <td align="center">힙 정렬</td>
    <td align="center">Heap Sort</td>
    <td align="center">O(N<sup>2</sup>)</td>
  </tr>
  <tr>
    <td align="center">08</td>
    <td align="center">계수 정렬</td>
    <td align="center">Counting Sort</td>
    <td align="center">O(N)</td>
  </tr>
  <tr>
    <td align="center">09</td>
    <td align="center">스택 구현</td>
    <td align="center">stack</td>
    <td align="center"></td>
  </tr>
  <tr>
    <td align="center">10</td>
    <td align="center">큐 구현</td>
    <td align="center">Queue</td>
    <td align="center"></td>
  </tr>
  <tr>
    <td align="center">11</td>
    <td align="center">BFS(너비 우선 탐색)</td>
    <td align="center">Breath First Search</td>
    <td align="center">O(V<sup>2</sup>)</td>
  </tr>
  <tr>
    <td align="center">12</td>
    <td align="center">DFS(깊이 우선 탐색)</td>
    <td align="center">Depth First Search</td>
    <td align="center">O(V<sup>2</sup>)</td>
  </tr>
  <tr>
    <td align="center">13</td>
    <td align="center">유니온 파인드</td>
    <td align="center">Union Find</td>
    <td align="center">O(logE)</td>
  </tr>
  <tr>
    <td align="center">14</td>
    <td align="center">최소 스패닝 트리</td>
    <td align="center">Kruskal Algorithm</td>
    <td align="center">O(E*logE)</td>
  </tr>
  <tr>
    <td align="center">15</td>
    <td align="center">바이너리 트리</td>
    <td align="center">Binary Tree</td>
    <td align="center"></td>
  </tr>
  <tr>
    <td align="center">16</td>
    <td align="center">다이나믹 프로그래밍</td>
    <td align="center">Dynamic Programming</td>
    <td align="center">O(N)</td>
  </tr>
  <tr>
    <td align="center">17</td>
    <td align="center">에라토스테네스의 체</td>
    <td align="center">Prime Number</td>
    <td align="center">O(N*logN*logN)</td>
  </tr>
  <tr>
    <td align="center">18</td>
    <td align="center">다익스트라 알고리즘</td>
    <td align="center">Dijkstra Algorithm</td>
    <td align="center">O(E*V*logV)</td>
  </tr>
  <tr>
    <td align="center">19</td>
    <td align="center">괄호문제</td>
    <td align="center">Parentheses</td>
    <td align="center"></td>
  </tr>
  <tr>
    <td align="center">20</td>
    <td align="center">분할 정복/td>
    <td align="center">Quad Tree</td>
    <td align="center">O(N*logN)</td>
  </tr>
  <tr>
    <td align="center">21</td>
    <td align="center">백트래킹</td>
    <td align="center">BackTracking</td>
    <td align="center">O(2<sup>N</sup>)</td>
  </tr>
  <tr>
    <td align="center">22</td>
    <td align="center">다익스트라 알고리즘2</td>
    <td align="center">Dijkstra Algorithm2</td>
    <td align="center">O(E*logV)</td>
  </tr>
  <tr>
    <td align="center">23</td>
    <td align="center">유클리드 호제법</td>
    <td align="center">Ecuild</td>
    <td align="center"></td>
  </tr>
  <tr>
    <td align="center">24</td>
    <td align="center">이분 매칭</td>
    <td align="center">Bipartite Matching</td>
    <td align="center">O(VE)</td>
  </tr>
  <tr>
    <td align="center">25</td>
    <td align="center">KMP 알고리즘</td>
    <td align="center">KMP Algorithm</td>
    <td align="center">O(N)</td>
  </tr>
  <tr>
    <td align="center">26</td>
    <td align="center">위상 정렬</td>
    <td align="center">Topology Sort</td>
    <td align="center">O(V+E)</td>
  </tr>
  <tr>
    <td align="center">27</td>
    <td align="center">세그먼트 트리</td>
    <td align="center">Segment Tree</td>
    <td align="center">O(N*logN)</td>
  </tr>
  <tr>
    <td align="center">28</td>
    <td align="center">플로이드 와샬</td>
    <td align="center">Floyd Warshall</td>
    <td align="center">O(V<sup>3</sup>)</td>
  </tr>
  <tr>
    <td align="center">29</td>
    <td align="center">느리게 갱신되는 세그먼트 트리</td>
    <td align="center">Segment Tree Lazy Propagation</td>
    <td align="center">O(N*logN)</td>
  </tr>
  <tr>
    <td align="center">30</td>
    <td align="center">외판원 순회</td>
    <td align="center">TSP</td>
    <td align="center">O(2<sup>N</sup>)</td>
  </tr>
  <tr>
    <td align="center">31</td>
    <td align="center">배낭 알고리즘</td>
    <td align="center">KnapSack</td>
    <td align="center">O(N*V)</td>
  </tr>
  <tr>
    <td align="center">32</td>
    <td align="center">최장 공통 문자열</td>
    <td align="center">LCS (Longest Common Substring)</td>
    <td align="center"></td>
  </tr>
  <tr>
    <td align="center">33</td>
    <td align="center">최장 공통 부분 문자열</td>
    <td align="center">LCS (Longest Common Subsequence)</td>
    <td align="center"></td>
  </tr>
  <tr>
    <td align="center">34</td>
    <td align="center">가장 긴 증가하는 부분 수열</td>
    <td align="center">LIS (Longest Increasing Subsequence)</td>
    <td align="center">O(N*logN)</td>
  </tr>
  <tr>
    <td align="center">35</td>
    <td align="center">최장 공통 조상</td>
    <td align="center">LCA (Longest Common Ancestor)</td>
    <td align="center">O(M*logN)</td>
  </tr>
  <tr>
    <td align="center">36</td>
    <td align="center">해시</td>
    <td align="center">Hash</td>
    <td align="center">O(1)</td>
  </tr>
  <tr>
    <td align="center">37</td>
    <td align="center">트라이</td>
    <td align="center">Trie</td>
    <td align="center">생성 시간복잡도: O(M*L)<br/>탐색 시간복잡도: O(L)<br/>(L: 제일 긴 문자열의 길이, M: 총 문자열 수)</td>
  </tr>
  <tr>
    <td align="center">38</td>
    <td align="center">머지소트 트리</td>
    <td align="center">MergeSort Tree</td>
    <td align="center">O(N*logN)</td>
  </tr>
  <tr>
    <td align="center">39</td>
    <td align="center">모스 알고리즘 + 오프라인 쿼리</td>
    <td align="center">mo's Algorithm + Offline Query</td>
    <td align="center">O((N+Q)√N * T(N))<br/>(T(N): 모스 알고리즘에서 숫자를 늘리거나 줄일때의 연산량)</td>
  </tr>
</table>
